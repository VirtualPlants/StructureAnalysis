"""Sequences

.. author:: Thomas Cokelaer, Thomas.Cokelaer@inria.fr

"""
__revision__ = "$Id: $"

import os
import openalea.stat_tool.interface as interface
from openalea.sequence_analysis._sequence_analysis import _Sequences
from openalea.sequence_analysis._sequence_analysis import _Renewal_data

import _sequence_analysis

__all__ = ['Sequences',
           '_Sequences',
           'LumpabilityTest',
           'RemoveIndexParameter',
           'TransformPosition']


# Extend dynamically class
interface.extend_class( _Sequences, interface.StatInterface)

# Add methods to _Vectors


def Sequences(*args, **kargs):
    """Construction of a set of sequences from multidimensional arrays of integers,
    from data generated by a renewal process or from an ASCII file.

    The data structure of type array(array(array(int))) should be constituted at the most internal level of arrays of constant size. If the optional argument IndexParameter is set at "Position" or "Time", the data structure of type array(array(array(int))) is constituted at the most internal level of arrays of size 1+n (index parameter, n variables attached to the explicit index parameter). If the optional argument IndexParameter is set at "Position", only the index parameter of the last array of size 1+n is considered and the first component of successive elementary arrays (representing the index parameter) should be increasing. If the optional argument IndexParameter is set at "Time", the first component of successive elementary arrays should be strictly increasing.
  
    :Parameters:

    * array1 (array(array(int))): input data for univariate sequences
    * arrayn (array(array(array(int)))): input data for multivariate sequences,
    * timev (renewal_data),
    * file_name (string).
    
    :Optional Parameters:
   
    * Identifiers (array(int)): explicit identifiers of sequences. This optional argument can only be used if the first argument is of type array(array(int/array(int))).
    * IndexParameter (string): type of the explicit index parameter: "Position" or "Time" (the default: implicit discrete index parameter starting at 0). This optional argument can only be used if the first argument is of type array(array(int/array(int))).
    
    :Returns:
    
    If the construction succeeds, an object of type sequences or discrete_sequences is returned, otherwise no object is returned. The returned object is of type discrete_sequences if all the variables are of type STATE, if the possible values for each variable are consecutive from 0 and if the number of possible values for each variable is <= 15.

    :Examples:
      
    >>> Sequences(array1, Identifiers=[1, 8, 12])
    >>> Sequences(arrayn, Identifiers=[1, 8, 12],
    >>> IndexParameter="Position")
    >>> Sequences(timev)
    >>> Sequences(file_name)    
    
    .. seealso::    
    
       :class:`~openalea.stat_tool.output.Save`,
       :func:`~openalea.sequence_analysis.data_transform.AddAbsorbingRun`,
       :func:`~openalea.stat_tool.cluster.Cluster`,
       :func:`~openalea.sequence_analysis.data_transform.Cumulate`,
       :func:`~openalea.sequence_analysis.data_transform.Difference`,
       :func:`~openalea.sequence_analysis.data_transform.IndexParameterExtract`, 
       :func:`~openalea.sequence_analysis.data_transform.LengthSelect`,
       :func:`~openalea.stat_tool.data_transform.Merge`,
       :func:`~openalea.stat_tool.data_transform.MergeVariable`,
       :func:`~openalea.sequence_analysis.data_transform.MovingAverage`,
       :func:`~openalea.sequence_analysis.data_transform.RecurrenceTimeSequences`,
       :func:`~openalea.sequence_analysis.data_transform.RemoveRun`,
       :func:`~openalea.sequence_analysis.data_transform.Reverse`,
       :func:`~openalea.sequence_analysis.data_transform.SegmentationExtract`,
       :func:`~openalea.stat_tool.data_transform.SelectIndividual`, 
       :func:`~openalea.stat_tool.data_transform.SelectVariable`,
       :func:`~openalea.stat_tool.data_transform.Shift`,
       :func:`~openalea.stat_tool.cluster.Transcode`, 
       :func:`~openalea.stat_tool.data_transform.ValueSelect`,
       :func:`~openalea.sequence_analysis.data_transform.VariableScaling`.
       :func:`~openalea.stat_tool.data_transform.ExtractHistogram`, 
       :func:`~openalea.sequence_analysis.data_transform.ExtractVectors`, 
       :func:`~openalea.sequence_analysis.correlation.ComputeCorrelation`, 
       :func:`~openalea.sequence_analysis.correlation.ComputePartialAutoCorrelation`, 
       :func:`~openalea.sequence_analysis.data_transform.ComputeSelfTransition`, 
       :func:`~openalea.sequence_analysis.compare.Compare`, 
       :func:`~openalea.sequence_analysis.estimate.Estimate`, 
       :func:`~openalea.sequence_analysis.data_transform.ComputeStateSequences`, 
       :func:`~openalea.sequence_analysis.simulate.Simulate`.

        
    .. todo:: refactoring using AML original code
    """ 
    
    type_map = {
        "INT": _sequence_analysis.INT_VALUE, 
        "REAL" : _sequence_analysis.REAL_VALUE,
        "STATE": _sequence_analysis.STATE,
        "NB_INTERNODE":  _sequence_analysis.NB_INTERNODE,
        "AUXILIARY":  _sequence_analysis.AUXILIARY,
        }
    
    index_parameter_type_map = {
        "IMPLICIT_TYPE": _sequence_analysis.IMPLICIT_TYPE,
        "TIME": _sequence_analysis.TIME,
        "TIME_INTERVAL": _sequence_analysis.TIME_INTERVAL,
        "POSITION": _sequence_analysis.POSITION,
        "POSITION_INTERVAL": _sequence_analysis.POSITION_INTERVAL
        }
 
    
    # by default, we use implicit
    index_parameter_type = kargs.get("IndexParameterType", "IMPLICIT_TYPE")
    #wrapper is looking for int or real 
    #type = kargs.get("Type","REAL_INT")    
        
    try:
        index_parameter_type = index_parameter_type_map[index_parameter_type]
    except KeyError:
        raise KeyError("Possible types are : " + 
                       str(index_parameter_type_map.keys()))
    
    sequence = None
    # First case: a filename constructor. So, let us check we have only one 
    # argument, which is a string
    if len(args)==1 and isinstance(args[0], str):
        filename = args[0]
        if os.path.isfile(filename):
            sequence = _Sequences(filename)
        else:
            raise IOError("bad file name")
    # otherwise, we switch to a list constructor that requires a list of seqs
    # and a list of identifiers. The latter being optional
    
    elif len(args) == 1 and isinstance(args[0], list):        
        sequence = _Sequences(args[0], range(0,len(args[0])),
                              index_parameter_type)
    # or may be provided by the user.
    elif len(args) == 2 and isinstance(args[0], list) and \
        isinstance(args[1], list):
        #if len(args[0])!=len(args[1]):
        #    raise TypeError("Expect the list of sequences and list of
        # identifiers to have the same length")
        sequence = _Sequences(args[0], args[1], index_parameter_type)
    elif len(args)==1 and isinstance(args[0], _Renewal_data):
        sequence = _Sequences(args[0])
    else:
        raise TypeError("Expected a valid filename or a list of lists (e.g., [[1,0],[0,1]])")
    
    try:
        output = sequence.markovian_sequences()
        if output:
            return output 
        else:
            raise Exception("invalid file ? Check the syntax")
    
    except:
        if sequence:
            return sequence
        else:
            raise Exception("invalid file ? Check the syntax")
    
    
def LumpabilityTest(obj, *args, **kargs):    
    """.. todo:: documenation"""
  
    symbol = args[0]
    Order = kargs.get("Order", 1)
    if isinstance(symbol, list):
        #nb_symbol = obj.get_marginal(0).nb_value;
        #todo: test if nb_symbol == len(symbol) ? ?
        status = obj.lumpability_test(symbol, Order)
        
    if status is False:
        #todo: not a type error, but anyway
        raise TypeError("warning: false status returned by lumpability test")
    else:
        raise TypeError("error expect list as second argument")
        
  
def RemoveIndexParameter(obj):
    """.. todo:: documenation
    
    input can be sequence, markovian_sequences, nonhomogeneous_markov, variable_order_markov"""
    return obj.remove_index_parameter()

def TransformPosition(obj, step=None):
    """.. todo:: documenation
    
    input is a sequence only"""
    if step == None:
        raise AttributeError("second arguments (step) must be provided")
    
    return obj.transform_position(step)

def ComputeInitialRun(obj):
    """.. todo:: documenation
    
    input can be sequence, markovian_sequences, nonhomogeneous_markov, 
    variable_order_markov
    """
    return obj.initial_run_computation()

    
        
