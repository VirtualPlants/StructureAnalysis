"""Sequences

.. author:: Thomas Cokelaer, Thomas.Cokelaer@inria.fr
uthor:/

"""
__revision__ = "$Id: $"

import os
import openalea.stat_tool.interface as interface
from openalea.sequence_analysis._sequence_analysis import _Sequences
from openalea.sequence_analysis._sequence_analysis import _Renewal_data
from openalea.sequence_analysis._sequence_analysis import _Markovian_sequences
from openalea.sequence_analysis._sequence_analysis import _Variable_order_markov_data
from openalea.sequence_analysis._sequence_analysis import _Semi_markov_data
from openalea.sequence_analysis._sequence_analysis import _Nonhomogeneous_markov_data
    
    
#import _sequence_analysis
from openalea.stat_tool import error



from enumerate import type_map, index_parameter_type_map

__all__ = ['Sequences',
           '_Sequences',
           'LumpabilityTest',
           'RemoveIndexParameter',
           'TransformPosition']


# Extend dynamically class
interface.extend_class( _Sequences, interface.StatInterface)

# Add methods to _Vectors


def Sequences(*args, **kargs):
    """Construction of a set of sequences from multidimensional arrays
    of integers, from data generated by a renewal process or from an
    ASCII file.

    The data structure of type array(array(array(int))) should be
    constituted at the most internal level of arrays of constant size. If the
    optional argument IndexParameter is set at "Position" or "Time", the data
    structure of type array(array(array(int))) is constituted at the most
    internal level of arrays of size 1 + n (index parameter, n variables
    attached to the explicit index parameter). If the optional argument
    IndexParameter is set at "Position", only the index parameter of the
    last array of size 1 + n is considered and the first component of successive
    elementary arrays (representing the index parameter) should be
    ncreasing. If the optional argument IndexParameter is set at "Time", the
    first component of successive elementary arrays should be strictly
    increasing.

  
    :Parameters:

    * array1 (array(array(int))): input data for univariate sequences
    * arrayn (array(array(array(int)))): input data for multivariate sequences,
    * timev (renewal_data),
    * file_name (string).
    
    :Optional Parameters:
   
    * Identifiers (array(int)): explicit identifiers of sequences. This optional argument can only be used if the first argument is of type array(array(int / array(int))).
    * IndexParameter (string): type of the explicit index parameter: "Position" or "Time" (the default: implicit discrete index parameter starting at 0). This optional argument can only be used if the first argument is of type array(array(int / array(int))).

    :Returns:
    
    If the construction succeeds, an object of type sequences or discrete_sequences is returned, otherwise no object is returned. The returned object is of type discrete_sequences if all the variables are of type STATE, if the possible values for each variable are consecutive from 0 and if the number of possible values for each variable is <= 15.

    :Examples:
      
    >>> Sequences(array1, Identifiers=[1, 8, 12])
    >>> Sequences(arrayn, Identifiers=[1, 8, 12], IndexParameter="Position")
    >>> Sequences(timev)
    >>> Sequences(file_name)    
    
    .. seealso::    
    
       :class:`~openalea.stat_tool.output.Save`,
       :func:`~openalea.sequence_analysis.data_transform.AddAbsorbingRun`,
       :func:`~openalea.stat_tool.cluster.Cluster`,
       :func:`~openalea.sequence_analysis.data_transform.Cumulate`,
       :func:`~openalea.sequence_analysis.data_transform.Difference`,
       :func:`~openalea.sequence_analysis.data_transform.IndexParameterExtract`, 
       :func:`~openalea.sequence_analysis.data_transform.LengthSelect`,
       :func:`~openalea.stat_tool.data_transform.Merge`,
       :func:`~openalea.stat_tool.data_transform.MergeVariable`,
       :func:`~openalea.sequence_analysis.data_transform.MovingAverage`,
       :func:`~openalea.sequence_analysis.data_transform.RecurrenceTimeSequences`,
       :func:`~openalea.sequence_analysis.data_transform.RemoveRun`,
       :func:`~openalea.sequence_analysis.data_transform.Reverse`,
       :func:`~openalea.sequence_analysis.data_transform.SegmentationExtract`,
       :func:`~openalea.stat_tool.data_transform.SelectIndividual`, 
       :func:`~openalea.stat_tool.data_transform.SelectVariable`,
       :func:`~openalea.stat_tool.data_transform.Shift`,
       :func:`~openalea.stat_tool.cluster.Transcode`, 
       :func:`~openalea.stat_tool.data_transform.ValueSelect`,
       :func:`~openalea.sequence_analysis.data_transform.VariableScaling`.
       :func:`~openalea.stat_tool.data_transform.ExtractHistogram`, 
       :func:`~openalea.sequence_analysis.data_transform.ExtractVectors`, 
       :func:`~openalea.sequence_analysis.correlation.ComputeCorrelation`, 
       :func:`~openalea.sequence_analysis.correlation.ComputePartialAutoCorrelation`, 
       :func:`~openalea.sequence_analysis.data_transform.ComputeSelfTransition`, 
       :func:`~openalea.sequence_analysis.compare.Compare`, 
       :func:`~openalea.sequence_analysis.estimate.Estimate`, 
       :func:`~openalea.sequence_analysis.data_transform.ComputeStateSequences`, 
       :func:`~openalea.sequence_analysis.simulate.Simulate`.

        
    .. todo:: refactoring using AML original code
    """ 
    
    index_parameter = error.ParseKargs(kargs, "IndexParameter", 
                                            "IMPLICIT_TYPE", 
                                            index_parameter_type_map)
    
    Identifiers = error.ParseKargs(kargs, "Identifiers", None)
    # all values must be positive strictly
    if Identifiers:
        assert len([x for x in Identifiers if x<=0]) == 0

    
    #wrapper is looking for int or real 
    #type = kargs.get("Type","REAL_INT")    
        
    sequence = None
    # First case: a filename constructor. So, let us check we have only one 
    # argument, which is a string
    if isinstance(args[0], str):
        filename = args[0]
        if os.path.isfile(filename):
            OldFormat = False
            sequence = _Sequences(filename, OldFormat)
        else:
            raise IOError("bad file name")
    # otherwise, we switch to a list constructor that requires a list of seqs
    # and a list of identifiers. The latter being optional
    elif isinstance(args[0], _Renewal_data):
        sequence = _Sequences(args[0])
        
    elif isinstance(args[0], list): 
    
        if Identifiers is None:  
            sequence = _Sequences(args[0], range(0, len(args[0])),
                              index_parameter)
            
        else:
        
            sequence = _Sequences(args[0], Identifiers, index_parameter)
    else:
        raise TypeError("Expected a valid filename or a list of lists (e.g., [[1,0],[0,1]])")
    
    #todo: simplify the following lines
    try:
        output = sequence.markovian_sequences()
        if output:
            return output 
        else:
            raise Exception("invalid file ? Check the syntax")
    
    except:
        if sequence:
            return sequence
        else:
            raise Exception("invalid file ? Check the syntax")
    
    
def LumpabilityTest(obj, *args, **kargs):    
    """.. todo:: documenation"""
    
    error.CheckArgumentsLength(args, 1, 1)
    error.CheckType([obj], [[_Markovian_sequences, _Variable_order_markov_data,
                            _Semi_markov_data, _Nonhomogeneous_markov_data]])
    
    
    symbol = args[0]
    Order = kargs.get("Order", 1)
    
    error.CheckType([symbol, Order], [list, int])
    
    ret = obj.lumpability_test(symbol, Order)
        
    if ret is False:
        raise TypeError("warning: false status returned by lumpability test")
        
  
def RemoveIndexParameter(obj):
    """.. todo:: documenation
    
    input can be sequence, markovian_sequences, 
    nonhomogeneous_markov, variable_order_markov"""
    
    error.CheckType([obj], [[_Sequences, _Markovian_sequences,
                             _Variable_order_markov_data, _Semi_markov_data, 
                             _Nonhomogeneous_markov_data]])
    if isinstance(obj, _Sequences):
        return obj.remove_index_parameter().markovian_sequences()
    else:
        return obj.remove_index_parameter()

def TransformPosition(obj, step=None):
    """.. todo:: documenation
    
    input is a sequence only"""
    error.CheckType([obj, step], [_Sequences, int])
    
    ret = obj.transform_position(step)
    if hasattr(obj, 'markovian_sequences'):
        return obj.markovian_sequences()
    else:
        return ret

def ComputeInitialRun(obj):
    """.. todo:: documenation
    
    input can be sequence, markovian_sequences, nonhomogeneous_markov, 
    variable_order_markov
    """
    error.CheckType([obj], [[_Markovian_sequences, _Variable_order_markov_data,
                             _Semi_markov_data, _Nonhomogeneous_markov_data]])
    return obj.initial_run_computation()


def Split(obj, step):
    """.. todo:: documentaiton
    
    input markovian
    """
    error.CheckType([obj], [[_Markovian_sequences, _Variable_order_markov_data, 
                            _Semi_markov_data, _Nonhomogeneous_markov_data]])
    error.CheckType([step], [int])
    
    return obj.split(step)
        
